# Проект Извод на типове

## Общ преглед
Проектът реализира извод на типове за Ламбда смятането, включващо променливи, абстакции и апликации, чрез алгоритъма J.

## Стартиране
За стартиране на интерактивната среда -> _`stack build && stack ghci`_  
Ето няколко примера, за по-лесно схващане:  
* `infer (ExpLam "x" (ExpVar "x"))` -> id
* `infer (ExpLam "x" (ExpLam "y" (ExpVar "x")))` -> const
* `infer (ExpLam "f" (ExpLam "x" (ExpApp (ExpVar "f")(ExpVar "x"))))` -> apply  
  
За пускане на тестовете -> _`stack test`_  

## Структура
Проектът включва три модула, като за всеки има тестове.
* Inferer  
Този модул съдържа основната част от извеждащия алгоритъм
* Types  
Този модул съдържа дефинициите на типовете, заедно с няколко помощни функции за тях
* Helper  
Този модул съдържа малко на брой помощни функции от общ характер
## Обосновка
<!-- ![Алгоритъмът J, както е представен ](https://wikimedia.org/api/rest_v1/media/math/render/svg/fe94a01f9724acb484213b8d45d3fd6cb29999f7) -->
### Няколко пояснения и дефиниции
**Монотип** са познатите ни типове( числа, низове, списъци ).  
**Политип** е тип, който има една или повече променливи под влиянието на квантор за всеобщност.  
**Контекст** - списък от наредени двойки *`(var, type)`*, където променливата *`var`* е от политип *`type`*. Записваме това с *`Г :- var:type`*.   
**Субституция** - списък от наредени двойки *`(vartype, type)`*, където *`vartype`* е типова променлива я заместваме с типа *`type`*. Прилагането на субституцията S на монотипа t означаваме с S_t.

### **Var**
Промелнива или име на функция.  
Ако 
* `Г :- x : s`
* `t` е инстанцирането на `s` ( `t = inst( s )` ) 

то `x : t`. 
### **Abs**
Декларация на функция.  
Ако 
* `t` е нова променлива
* `Г, x : t :- e : s` 

то `Г :- \x.e : t -> s`.
### **App**
Извикване на функция с един параметър.  
Aко
* `Г :- e0 : t0`
* `Г :- e1 : t1`
* `t'` е нова типова променлива
* `t0` се унифицира с `t1 -> t'`

то `Г :- (e0 e1) : t'`
### **Inst**
Специализиране на типовете. Премахваме кванторите по променливите.
Ако 
* `Г :- e : s'`
* `s` е по-конкретен тип от  `s'` (в линейната наредба на типовете  `s' < s`)
  
то `Г :- e : s`
### **Gen**
Генерализиране на типовете. Квантуваме променливи, които са били свободни.
Ако
* `Г :- e : s`
* `a` не принадлежи на свободните променливи на `Г`

то `Г :- e : forall a . s`

## Имплементация

* `type NameGenerator a = ExceptT String (State Int) a`  
   Смисълът на този монад е двоен. От една страна има функционалността на `Either` - позволява ни да пазим грешки, без да прекъсваме нормалния ход на програмата, от друга страна пази в `State` цяло число, което ползваме, за да генерираме уникални имена на променливи(не е толкова чисто, колкото математическата теория).
* `type Context  = [(VarName, Polytype)]` 
    Представям контекста като асоциативен списък от имена на променливи и политипове. В модула `Helper` има дефинирани няколко помощни функции, които да улеснят работата с тази не толкова лесна за работа структура
* `type Substitution = [(VarName, Type)]`
    Подобно на контекста, субституциите също са представени като асоциативен списък, но от имена на променливи и типове. Съшите помощни функции, бидейки полиморфни, се използват и за тази структура.

Функциите в модула `Inferer` имплементират математическите алгоритми, описани по-горе, доколкото е възможно. В някои се налага да бъде връщан монадът `NameGenerator`, тъй като желаем да не генераме две нови променливи с еднакви имена в две различни места в кода, което би довело до нежелания и грешен _`occurs check failed`_.

### **Възможни грешки**
Програмата връща два типа грешки
* *Occurs check failed*  
    Тази грешка бива връщана от `unify` алгоритъма, когато се опитаме да уеднаквим променлива и функция, която съдържа въпросната променлива. Това би довело до безкраен тип, който не е дефиниран в нашата версия на ламбда смятането.
* *Unbound variable `v`*  
    Тази грешка бива връщана от `inference` алгоритъма директно, когато се опитва да намери типа на променлива, която не е в контекста. Това означава, че имаме променлива, която не е вход на никоя ламбда функция до сега и играе ефективно ролята на константа. Тъй като нямаме първоначален контекст, който да се грижи за това, няма как да намерим типа на тази променлива и връщаме грешка.


## Ресурси
[Wiki страницата за типовата система Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)

[Кратка лекция за извод на типове в Haskell](https://www.youtube.com/watch?v=ytPAlhnAKro)

## Бележки  
Няма тестове за функциите, които връщат монад.

